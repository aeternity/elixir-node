#Function-related ignored errors.
The created fun has no local return
Function encode_to_map/1 has no local return
Function insert_call/2 has no local return
Function get_call_gas_used/4 has no local return
Function process_chainstate/6 has no local return
Function handle_info/2 has no local return
The created fun has no local return
Function oracle_query/2 has no local return
Function broadcast_new_block_added_to_chain_and_new_mined_tx/1 has no local return
Function do_call_contract/3 has no local return
Function init_chain/2 has no local return
Function create/4 has no local return

Function known_chain/1 will never be called
Function identify_chain/1 will never be called
Function do_get_header_by_height/3 will never be called
Function work_on_sync_task/2 will never be called
Function work_on_sync_task/3 will never be called
Function post_blocks/1 will never be called
Function post_blocks/3 will never be called
Function agree_on_height/7 will never be called
Function fill_pool/4 will never be called
Function fetch_block/2 will never be called
unction fetch_block_ext/2 will never be called




apps/aecore/lib/aecore/account/account_state_tree.ex:5: Overloaded contract for 'Elixir.Aecore.Account.AccountStateTree':get/2 has overlapping domains; such contracts are currently unsupported and are simply ignored
apps/aecore/lib/aecore/chain/block.ex:31: The call maps:put(#{#<116>(8, 1, 'integer', ['unsigned', 'big']), #<114>(8, 1, 'integer', ['unsigned', 'big']), #<97>(8, 1, 'integer', ['unsigned', 'big']), #<110>(8, 1, 'integer', ['unsigned', 'big']), #<115>(8, 1, 'integer', ['unsigned', 'big']), #<97>(8, 1, 'integer', ['unsigned', 'big']), #<99>(8, 1, 'integer', ['unsigned', 'big']), #<116>(8, 1, 'integer', ['unsigned', 'big']), #<105>(8, 1, 'integer', ['unsigned', 'big']), #<111>(8, 1, 'integer', ['unsigned', 'big']), #<110>(8, 1, 'integer', ['unsigned', 'big']), #<115>(8, 1, 'integer', ['unsigned', 'big'])}#,Vserialized_txs@1::[any()],Vserialized_header@1::binary()) will never return since it differs in the 3rd argument from the success typing arguments: (any(),any(),map())
apps/aecore/lib/aecore/chain/worker.ex:452: The call 'Elixir.Aeutil.Serialization':remove_struct(Vblocks_info@1::'not_found' | {'error',_} | {'ok',map()}) breaks the contract ([map()]) -> [any()]
    ; (map()) -> map() in the 1st argument

apps/aecore/lib/aecore/chain/worker.ex:562: The call 'Elixir.Aecore.Chain.Worker':transform_chainstate('to_chainstate',Vchainstate@1::map()) will never return since the success typing is (any(),{'error',_} | {'ok',map()}) -> any() and the contract is (any(),{'error',any()} | {'ok',map()}) -> any()
apps/aecore/lib/aecore/chain/worker.ex:562: The call 'Elixir.Aecore.Chain.Worker':transform_chainstate('to_chainstate',Vchainstate@1::map()) will never return since the success typing is (any(),{'error',_} | {'ok',_}) -> any() and the contract is (atom() | any(),{'error','Elixir.String':t()} | {'ok',map()}) -> map()
apps/aecore/lib/aecore/contract/contract.ex:154: The pattern Verror@1 = {'error', _} can never match the type 'false'
apps/aeutil/lib/patricia_merkle_tree.ex:43: Overloaded contract for 'Elixir.Aeutil.PatriciaMerkleTree':new/1 has overlapping domains; such contracts are currently unsupported and are simply ignored
apps/aehttpclient/lib/client.ex:91: The pattern <'pool_txs', Vbody@1, _headers@1> can never match the type <'default',_,[any()]>
apps/aehttpserver/lib/aehttpserver/web/controllers/oracle_controller.ex:68: The pattern #{'data':=#{'payload':=#{'query_data':=Vquery_data@1, 'oracle_address':=#{'value':=Vvalue@1}, 'response_ttl':=Vresponse_ttl@1, 'query_ttl':=Vquery_ttl@1, 'query_fee':=Vquery_fee@1}, 'fee':=Vfee@1}} can never match the type #{'__struct__':='Elixir.Aecore.Tx.SignedTx', 'data':=#{'__struct__':='Elixir.Aecore.Tx.DataTx', 'fee':=non_neg_integer(), 'nonce':=non_neg_integer(), 'payload':=#{'__struct__':=atom(), 'amount'=>non_neg_integer(), 'call_data'=>binary(), 'call_stack'=>[non_neg_integer()], 'channel_id'=>binary(), 'channel_reserve'=>non_neg_integer(), 'client_ttl'=>non_neg_integer(), 'code'=>binary(), 'commitment'=>#{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}, 'contract'=>#{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}, 'deposit'=>non_neg_integer(), 'depositing_account'=>binary(), 'expire_by'=>non_neg_integer(), 'gas'=>non_neg_integer(), 'gas_price'=>non_neg_integer(), 'hash'=>binary() | #{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}, 'initiator_amount'=>non_neg_integer(), 'locktime'=>non_neg_integer(), 'name'=>binary(), 'name_salt'=>integer(), 'offchain_tx'=>'empty' | #{'__struct__':='Elixir.Aecore.Channel.ChannelOffChainTx', 'channel_id':=binary(), 'sequence':='nil' | non_neg_integer(), 'signatures':={binary(),binary()}, 'state_hash':='nil' | binary(), 'updates':=[#{'__struct__':='Elixir.Aecore.Channel.Updates.ChannelCreateUpdate' | 'Elixir.Aecore.Channel.Updates.ChannelDepositUpdate' | 'Elixir.Aecore.Channel.Updates.ChannelTransferUpdate' | 'Elixir.Aecore.Channel.Updates.ChannelWithdrawUpdate', 'amount'=>non_neg_integer(), 'channel_reserve'=>non_neg_integer(), 'from'=>binary(), 'initiator'=>binary(), 'initiator_amount'=>non_neg_integer(), 'locktime'=>non_neg_integer(), 'responder'=>binary(), 'responder_amount'=>non_neg_integer(), 'to'=>binary()}]}, 'payload'=>binary(), 'poi'=>#{'__struct__':='Elixir.Aecore.Poi.Poi', 'accounts':=#{'__struct__':='Elixir.Aecore.Poi.PoiProof', 'db':=map(), 'root_hash':='empty' | binary()}, 'calls':=#{'__struct__':='Elixir.Aecore.Poi.PoiProof', 'db':=map(), 'root_hash':='empty' | binary()}, 'channels':=#{'__struct__':='Elixir.Aecore.Poi.PoiProof', 'db':=map(), 'root_hash':='empty' | binary()}, 'contracts':=#{'__struct__':='Elixir.Aecore.Poi.PoiProof', 'db':=map(), 'root_hash':='empty' | binary()}, 'naming':=#{'__struct__':='Elixir.Aecore.Poi.PoiProof', 'db':=map(), 'root_hash':='empty' | binary()}, 'oracles':=#{'__struct__':='Elixir.Aecore.Poi.PoiProof', 'db':=map(), 'root_hash':='empty' | binary()}}, 'pointers'=>binary(), 'query_fee'=>non_neg_integer(), 'query_format'=>binary(), 'query_id'=>binary(), 'receiver'=>binary() | #{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}, 'responder_amount'=>non_neg_integer(), 'response'=>binary(), 'response_format'=>binary(), 'sequence'=>non_neg_integer(), 'state_hash'=>binary(), 'target'=>#{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}, 'ttl'=>#{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'version'=>non_neg_integer(), 'vm_version'=>integer(), 'withdrawing_account'=>binary()}, 'senders':=[#{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}] | #{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}, 'ttl':=non_neg_integer(), 'type':=atom()}, 'signatures':=[binary()]}
apps/aecore/lib/aecore/tx/signed_tx.ex:217: The pattern {'ok', _} can never match the type 'error'
apps/aecore/lib/aecore/tx/signed_tx.ex:227: The pattern {'ok', Vremaining_signatures@1} can never match the type 'error'
apps/aecore/lib/aecore/tx/signed_tx.ex:212: Invalid type specification for function 'Elixir.Aecore.Tx.SignedTx':'signature_valid_for?'/2. The success typing is (#{'__struct__':='Elixir.Aecore.Tx.SignedTx', 'data':=#{'__struct__':='Elixir.Aecore.Tx.DataTx', 'fee':=non_neg_integer(), 'nonce':=non_neg_integer(), 'payload':=#{'__struct__':=atom(), 'amount'=>non_neg_integer(), 'call_data'=>binary(), 'call_stack'=>[any()], 'channel_id'=>binary(), 'channel_reserve'=>non_neg_integer(), 'client_ttl'=>non_neg_integer(), 'code'=>binary(), 'commitment'=>map(), 'contract'=>map(), 'deposit'=>non_neg_integer(), 'depositing_account'=>binary(), 'expire_by'=>non_neg_integer(), 'gas'=>non_neg_integer(), 'gas_price'=>non_neg_integer(), 'hash'=>binary() | map(), 'initiator_amount'=>non_neg_integer(), 'locktime'=>non_neg_integer(), 'name'=>binary(), 'name_salt'=>integer(), 'offchain_tx'=>'empty' | map(), 'payload'=>binary(), 'poi'=>map(), 'pointers'=>binary(), 'query_fee'=>non_neg_integer(), 'query_format'=>binary(), 'query_id'=>binary(), 'receiver'=>binary() | map(), 'responder_amount'=>non_neg_integer(), 'response'=>binary(), 'response_format'=>binary(), 'sequence'=>non_neg_integer(), 'state_hash'=>binary(), 'target'=>map(), 'ttl'=>map(), 'version'=>non_neg_integer(), 'vm_version'=>integer(), 'withdrawing_account'=>binary()}, 'senders':=[map()] | #{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}, 'ttl':=non_neg_integer(), 'type':=atom()}, 'signatures':=_, _=>_},#{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}) -> 'false'
apps/aecore/lib/aecore/tx/signed_tx.ex:253: The call 'Elixir.Aecore.Keys':verify(Vdata_binary@1::binary(),Vsignature@1::any(),Vpubkey@1::#{'__struct__':='Elixir.Aecore.Chain.Identifier', 'type':='account' | 'channel' | 'commitment' | 'contract' | 'name' | 'oracle', 'value':=binary()}) will never return since the success typing is (binary(),binary(),binary()) -> boolean() and the contract is (message(),signature(),pubkey()) -> boolean()
apps/aehttpclient/lib/client.ex:63: The pattern <'raw_blocks', Vbody@1, _headers@1> can never match the type <'acc_txs' | 'default' | 'info',_,[any()]>
